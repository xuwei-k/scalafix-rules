# scalafix rules

[![maven](https://img.shields.io/maven-central/v/com.github.xuwei-k/scalafix-rules_2.13)](https://search.maven.org/artifact/com.github.xuwei-k/scalafix-rules_2.13)
[![scaladoc](https://javadoc.io/badge2/com.github.xuwei-k/scalafix-rules_2.13/javadoc.svg)](https://javadoc.io/doc/com.github.xuwei-k/scalafix-rules_2.13/latest/fix/index.html)

| scalafix | scalafix-rules |
|----------|----------------|
| 0.14.x   | 0.6.x          |
| 0.13.x   | 0.5.x          |
| 0.12.x   | 0.4.x          |

`project/plugins.sbt`

```scala
addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "<version>")
```

`build.sbt`

```scala
ThisBuild / scalafixDependencies += "com.github.xuwei-k" %% "scalafix-rules" % "<version>"
```

or

```
sbt > scalafixAll dependency:SomeRuleName@com.github.xuwei-k:scalafix-rules:version
```

or

```
sbt > scalafixAll https://raw.githubusercontent.com/xuwei-k/scalafix-rules/main/rules/src/main/scala/fix/SomeRuleName.scala
```

## Rule Summary

| Rule Name                                                                           | Description                                                                                                                                                                                                                                                                                                                                                  | Example                                                                                                                                                                                                                                                                         |
|-------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **AddExplicitImplicitTypes**                                                        | Automatically adds explicit type annotations to implicit definitions that lack them. This ensures implicit `val` or `def` have a clearly declared result type, improving code clarity and avoiding type-inference issues.                                                                                                                                    | **Before:** `implicit val ctx = new Context()`<br>**After:** `implicit val ctx: Context = new Context()`                                                                                                                                                                        |
| **AddLambdaParamParentheses**                                                       | Wraps single-parameter lambdas in parentheses when they were previously omitted. This rule makes lambdas with one parameter syntactically explicit, preventing confusion or parsing issues (especially migrating to Scala 3).                                                                                                                                | **Before:** `list.map{ x => println(x) }`<br>**After:** `list.map{ (x) => println(x) }`                                                                                                                                                                                         |
| **AutoEtaExpansion**                                                                | Expands method references to functions automatically by adding the placeholder `_` where needed. In other words, if a method is used where a function is expected, this rule inserts an eta-expansion placeholder to convert it into a function value.                                                                                                       | **Before:** `val f: Int => String = obj.method`<br>**After:** `val f: Int => String = obj.method _`                                                                                                                                                                             |
| **AvoidApply**                                                                      | Avoids redundant explicit calls to `.apply` on objects or case classes when they can be omitted. The rule rewrites such calls to the simpler form, improving code conciseness and readability.                                                                                                                                                               | **Before:** `val opt = Option.apply(42)`<br>**After:** `val opt = Option(42)`                                                                                                                                                                                                   |
| **CaseClassImplicitVal**                                                            | Flags or fixes the usage of `implicit val` inside case classes, which can be problematic. The rule encourages moving implicits out of case classes or giving them explicit types to avoid unintended behaviors or initialization issues.                                                                                                                     | **Before:** `case class Config(implicit val ec: ExecutionContext)`<br>**After:** *(implicit moved out or made explicit)*                                                                                                                                                        |
| **CatsImplicitsImport**                                                             | Ensures the appropriate import of Cats implicit conversions. It may add or replace imports to use `cats.implicits._` when needed, unifying import style and preventing missing instances in Cats type classes.                                                                                                                                               | **Before:** *(Missing Cats implicits import, causing missing typeclass instances)*<br>**After:** `import cats.implicits._`                                                                                                                                                      |
| **CatsInstancesImport**                                                             | Rewrites imports to use specific Cats instances or ensures required instance imports are present. This helps avoid relying on deprecated or ambiguous imports by explicitly importing the needed `cats.instances.X` for a given type.                                                                                                                        | **Before:** *(Using a Cats type without importing its instances)*<br>**After:** `import cats.instances.option._`                                                                                                                                                                |
| **CatsToValid**                                                                     | Replaces usage of Cats’ older `X.toValidated`/`X.toInvalid` patterns with the newer `toValid`/`toInvalid` methods. This makes code use the current Cats API for converting `Option` or `Either` to `Validated`.                                                                                                                                              | **Before:** `option.toInvalid(new Error)`<br>**After:** `option.toValid(new Error)`                                                                                                                                                                                             |
| **CirceCodec**                                                                      | Transforms usage of Circe’s `@JsonCodec` (or manual codec definitions) to a more idiomatic or updated form. It might replace macro annotations or optimize how encoder/decoder are derived to align with current Circe best practices.                                                                                                                       | **Before:** `@JsonCodec case class Data(x: Int)`<br>**After:** *(Generates or uses explicit Encoder/Decoder for Data)*                                                                                                                                                          |
| **CollectHead**                                                                     | Rewrites patterns that use `collect { case ... }.head` to a safer or clearer alternative. Instead of collecting and then taking head (which can throw), it may suggest using `collectFirst` or other safe combinators to get the first match.                                                                                                                | **Before:** `list.collect{ case i if i > 0 => i }.head`<br>**After:** `list.collectFirst{ case i if i > 0 => i }.get`                                                                                                                                                           |
| **CollectHeadOption**                                                               | Similar to *CollectHead*, but addresses uses of `.collect(...).headOption`. It may simplify such calls to use `collectFirst` directly, which yields an Option and is more direct than collect + headOption.                                                                                                                                                  | **Before:** `xs.collect{ case s: String => s }.headOption`<br>**After:** `xs.collectFirst{ case s: String => s }`                                                                                                                                                               |
| **CompareSameValue**                                                                | Detects comparisons where the same value is on both sides (e.g. `x == x` or `x.equals(x)`). Such redundant comparisons are removed or highlighted as always true/false, helping eliminate tautologies or self-comparisons.                                                                                                                                   | **Before:** `if (count == count) doSomething()`<br>**After:** `doSomething()` (since the condition is always true)                                                                                                                                                              |
| **DirectoryAndPackageName**                                                         | Ensures that the package declarations in Scala files match the directory structure. If a file’s package does not correspond to its folder path, this rule adjusts the package statement to the correct namespace.                                                                                                                                            | **Before:** (in file `utils/Helper.scala`) `package com.example`<br>**After:** `package com.example.utils`                                                                                                                                                                      |
| **DiscardCatsEffectIO**                                                             | Flags any `cats.effect.IO` that is created or run and then ignored (not used or awaited). It encourages handling side effects properly by, for example, sequencing the IO or explicitly running it for its result rather than discarding it.                                                                                                                 | **Before:** `IO(println("done")) // result not used`<br>**After:** `IO(println("done")).unsafeRunSync()` (or handled)                                                                                                                                                           |
| **DiscardEff**                                                                      | Similar to other “Discard” rules, but for the Eff monad (from the Eff library). It warns when an `Eff` effect is executed or computed without using its result. The rule promotes handling or returning the effect instead of ignoring it.                                                                                                                   | **Before:** `runEffect(effect)` (result ignored)<br>**After:** `val result = runEffect(effect)` (store or use result)                                                                                                                                                           |
| **DiscardMonixTask**                                                                | Detects when a Monix `Task` is invoked or started and its result is not used. The rule suggests not discarding the Task—either await its completion or explicitly acknowledge its launch—thus preventing silent task execution.                                                                                                                              | **Before:** `Task(eval(42)).runAsyncAndForget()`<br>**After:** `Task(eval(42)).runToFuture` (and handle Future result)                                                                                                                                                          |
| **DiscardScalaFuture**                                                              | Flags situations where a `scala.concurrent.Future` is created and not utilized (not assigned or awaited). This encourages proper handling of asynchronous results, as ignoring a Future’s result can hide bugs or lost computations.                                                                                                                         | **Before:** `Future { compute() } // result ignored`<br>**After:** `Future { compute() }.onComplete(println)` (handle it)                                                                                                                                                       |
| **DiscardSlickDBIO**                                                                | Warns when a Slick `DBIO` action is created or run and then thrown away without using the result or running it on a database. The rule nudges developers to execute the action or capture its result instead of doing nothing with it.                                                                                                                       | **Before:** `db.run(query) // ignoring returned Future`<br>**After:** `db.run(query).map(processResult)`                                                                                                                                                                        |
| **DiscardValue**                                                                    | A generic check that flags any computed value of certain types that is not used. It likely underpins the other discard rules (configured with specific types), ensuring no important result (especially effectful computations) is lost.                                                                                                                     | **Before:** `computeExpensiveValue(); ()`<br>**After:** `val res = computeExpensiveValue()` (or explicitly ignore with comment)                                                                                                                                                 |
| **DuplicateWildcardImport**                                                         | Removes duplicate wildcard imports of the same package/object. If the same `import x._` appears multiple times, the extras are redundant and are deleted to clean up the imports.                                                                                                                                                                            | **Before:** `import scala.concurrent._; import scala.concurrent._`<br>**After:** `import scala.concurrent._`                                                                                                                                                                    |
| **EitherFold**                                                                      | Simplifies or flags improper uses of `Either#fold`. It may encourage using pattern matching or direct methods on `Either` now that it’s right-biased, or ensure that `fold` usage is replaced with clearer alternatives (like `.map` or `.swap` combinations).                                                                                               | **Before:** `e.fold(handleLeft, handleRight)`<br>**After:** *(Possibly use pattern match or other Either methods)*                                                                                                                                                              |
| **EitherGetOrElse**                                                                 | Replaces patterns where an `Either` is converted to a value with a default on left (commonly done via `either.fold(default, identity)` or similar). It encourages using `getOrElse` on the projected Right or other direct methods for clarity.                                                                                                              | **Before:** `val x = e.fold(_ => default, identity)`<br>**After:** `val x = e.getOrElse(default)`                                                                                                                                                                               |
| **EitherMap**                                                                       | Updates legacy idioms of mapping over an `Either`. For instance, it replaces usage of the left/right projection or `fold` for mapping with direct `either.map` (for the right) or `either.leftMap`/`swap.map` as appropriate, leveraging right-bias.                                                                                                         | **Before:** `e.right.map(f)`<br>**After:** `e.map(f)` (since `Either` is right-biased)                                                                                                                                                                                          |
| **EtaExpand**                                                                       | Ensures functions or methods are fully eta-expanded when needed. It likely complements AutoEtaExpansion, making sure no partial application is missed by explicitly adding `_` to convert methods into function values where required.                                                                                                                       | **Before:** `list.map(method)` (where method is not auto-applied)<br>**After:** `list.map(method _)`                                                                                                                                                                            |
| **ExplicitImplicitTypes**                                                           | Lints implicit declarations that lack an explicit type (similar to *AddExplicitImplicitTypes*). Rather than adding the type, this rule may just warn or fail the build, enforcing that implicits must have result type annotations for clarity.                                                                                                              | **Before:** `implicit def mkInt = "42".toInt`<br>**After:** `implicit def mkInt: Int = "42".toInt`                                                                                                                                                                              |
| **ExtendsProductWithSerializable**                                                  | Flags case classes or enums that implicitly extend `Product with Serializable`. In Scala, case classes automatically extend those; explicitly extending them is redundant. The rule removes unnecessary `extends Product with Serializable`.                                                                                                                 | **Before:** `case class Data(x: Int) extends Product with Serializable`<br>**After:** `case class Data(x: Int)`                                                                                                                                                                 |
| **FileNameConsistent**                                                              | Ensures Scala file names align with the single public class/trait/object they contain. If a file’s name doesn’t match the case class or object inside, this rule either warns or suggests a rename to maintain consistency between file and class name.                                                                                                      | **Before:** *File `UserUtils.scala` contains `object UserHelper`*<br>**After:** *File is renamed to `UserHelper.scala`*                                                                                                                                                         |
| **FilterNot**                                                                       | Encourages using `filterNot` instead of `filter` with a negated condition for clarity. It transforms code where `filter(x => !cond(x))` into the more idiomatic `filterNot(cond)`, making intent clearer.                                                                                                                                                    | **Before:** `seq.filter(x => !isValid(x))`<br>**After:** `seq.filterNot(isValid)`                                                                                                                                                                                               |
| **FilterSize**                                                                      | Simplifies calls to get the count of filtered elements. For example, it may rewrite `collection.filter(p).size` to the more direct `count(p)`, which conveys intent and potentially improves performance by not building an intermediate collection.                                                                                                         | **Before:** `items.filter(isGood).size`<br>**After:** `items.count(isGood)`                                                                                                                                                                                                     |
| **FinalObjectWarn**                                                                 | Warns if an `object` is marked `final` (which is unnecessary, since objects in Scala are implicitly final). The rule doesn’t need to rewrite anything, but it will point out that `final` on a singleton object is superfluous and can be removed.                                                                                                           | **Before:** `final object Constants { ... }`<br>**After:** `object Constants { ... }`                                                                                                                                                                                           |
| **FlatMapCollect**                                                                  | Streamlines patterns where `.map` is followed by `.flatten`, specifically for Options or other monads. It replaces a `map(...).flatten` sequence with a single `flatMap(...)`, which is more idiomatic and avoids intermediate structures.                                                                                                                   | **Before:** `opt.map(f).flatten`<br>**After:** `opt.flatMap(f)`                                                                                                                                                                                                                 |
| **FlatTraverse**                                                                    | Merges sequential `.map` and `.sequence` (or similar) calls into a single `traverse` call. For example, if code does `list.map(f).sequence`, the rule rewrites it to `list.traverse(f)`, which is clearer and often more efficient in FP libraries.                                                                                                          | **Before:** `options.map(optToEither).sequence`<br>**After:** `options.traverse(optToEither)`                                                                                                                                                                                   |
| **ForTupleMatch**                                                                   | Addresses the usage of tuple patterns in for-comprehensions. In Scala 3, for-comprehension generators cannot directly deconstruct tuples with `case`. This rule changes `for { case (a,b) <- ... }` into a form compatible with Scala 3 (e.g., by adding an explicit generator and pattern match).                                                           | **Before:** `for { case (a,b) <- pairs } yield f(a,b)`<br>**After:** `for { t <- pairs; (a,b) = t } yield f(a,b)`                                                                                                                                                               |
| **GroupMap**                                                                        | Rewrites verbose groupBy-then-map operations into Scala 2.13’s concise `groupMap`. Instead of grouping and then transforming values, it uses `groupMap` which does both in one step, making the code shorter and clearer.                                                                                                                                    | **Before:** `xs.groupBy(key).map{ case (k, vs) => k -> vs.map(f) }`<br>**After:** `xs.groupMap(key)(f)`                                                                                                                                                                         |
| **ImplicitValueClass**                                                              | Flags definitions of implicit value classes that don’t follow recommended guidelines (like having exactly one constructor parameter). It may also ensure the class is `final` and extends `AnyVal`. The rule prevents misuse of implicit classes as value classes.                                                                                           | **Before:** `implicit class RichInt(i:Int){ def foo = 42 }`<br>**After:** `implicit final class RichInt(val i:Int) extends AnyVal { def foo = 42 }`                                                                                                                             |
| **IncorrectScaladocParam**                                                          | Detects mismatches between Scaladoc `@param` tags and actual parameters. For example, if a Scaladoc comment refers to a parameter name that doesn’t exist or is misspelled, the rule highlights or removes it, ensuring documentation accuracy.                                                                                                              | **Before:** `/** ... @param count the number of items ... */ def size: Int = ...` (no param named count)<br>**After:** `/** ... */ def size: Int = ...` (incorrect tag removed)                                                                                                 |
| **InterpolationToString**                                                           | Replaces uses of string concatenation or `.format` that simulate interpolation with real string interpolation. It transforms expressions like `f + " = " + x` or `"%d apples".format(n)` into s-interpolated strings for conciseness and clarity.                                                                                                            | **Before:** `val msg = "%s=%d".format(name, count)`<br>**After:** `val msg = s"$name=$count"`                                                                                                                                                                                   |
| **InterpolationToStringWarn**                                                       | Warns about using `.toString` inside string interpolations unnecessarily. For example, it would flag s`${value.toString}` since `${value}` is equivalent. The rule nudges developers to remove explicit `.toString` calls within interpolated strings.                                                                                                       | **Before:** `scala val msg = s"Result: ${res.toString}"`<br>**After:** `scala val msg = s"Result: $res"`                                                                                                                                                                        |
| **IntersectionType**                                                                | Rewrites uses of the legacy intersection type syntax using `with` to the new `&` operator in Scala 3. For instance, a type declared as `A with B` is changed to `A & B`, which is the recommended way to denote intersection types going forward.                                                                                                            | **Before:** `def combine(x: A with B): A with B = ...`<br>**After:** `def combine(x: A & B): A & B = ...`                                                                                                                                                                       |
| **IsEmptyNonEmpty**                                                                 | Simplifies checks for emptiness by using `.isEmpty` or `.nonEmpty` appropriately. For example, it may rewrite `!coll.nonEmpty` to `coll.isEmpty`, or `!coll.isEmpty` to `coll.nonEmpty`, resulting in clearer and more idiomatic emptiness checks.                                                                                                           | **Before:** `if (!list.isEmpty) ...`<br>**After:** `if (list.nonEmpty) ...`                                                                                                                                                                                                     |
| **JavaURLConstructorsWarn**                                                         | Flags the use of older Java URL constructors (e.g., `new URL("http", ...)`) that are considered unsafe or deprecated. It encourages using more modern APIs or properly encoding URLs instead of relying on those legacy constructors.                                                                                                                        | **Before:** `new java.net.URL("http", host, "/path")`<br>**After:** *Warns to use URI or encode components properly*                                                                                                                                                            |
| **KeySet**                                                                          | Rewrites usage of `map.keys.toSet` or similar constructs to the direct `map.keySet`. Accessing the `keySet` property is more efficient and concise than converting the keys iterator to a set via an intermediate collection.                                                                                                                                | **Before:** `val ks = myMap.keys.toSet`<br>**After:** `val ks = myMap.keySet`                                                                                                                                                                                                   |
| **KindProjector**                                                                   | Removes or updates syntax that was only necessary due to lack of kind-projector plugin in Scala 3. For example, it can replace the use of the Lambda (λ) type lambdas or the placeholder `*` with Scala 3’s built-in type lambda syntax, making code compatible.                                                                                             | **Before:** `({ type L[X] = Either[Error, X] })#L`<br>**After:** `Either[Error, *]` (Scala 3 type lambda syntax)                                                                                                                                                                |
| **KindProjectorScala3TypeLambda**                                                   | Similar to *KindProjector*, this specifically targets the Scala 3 `?_` wildcard syntax for type lambdas introduced in Dotty. It ensures that the new syntax (like `[*] ->>` type lambda notation) is used or warns if kind-projector constructs aren’t adapted to Scala 3 syntax.                                                                            | **Before:** `FunctionK[Option, Either[Error, *]]` (with Scala 2 syntax)<br>**After:** `Option ~> Either[Error, *]` (using Scala 3 syntax)                                                                                                                                       |
| **LambdaParamParentheses**                                                          | Ensures that multi-parameter lambdas have proper parentheses around their parameter lists. If a lambda has multiple parameters and was written without parentheses, this rule adds them for correctness (especially as Scala 3 requires parentheses around multiple lambda params).                                                                          | **Before:** `list.foldLeft(0){ acc, x => acc + x }`<br>**After:** `list.foldLeft(0){ (acc, x) => acc + x }`                                                                                                                                                                     |
| **LazyZip**                                                                         | Replaces usage of `zip` followed by separate traversals with the more efficient `lazyZip`. In Scala 2.13+, `lazyZip` can zip collections without constructing intermediate tuples eagerly. This rule encourages using `lazyZip` for performance in certain cases.                                                                                            | **Before:** `xs.zip(ys).map{ case (x,y) => f(x,y) }`<br>**After:** `(xs lazyZip ys).map(f)`                                                                                                                                                                                     |
| **MapDistinctSize**                                                                 | Optimizes patterns where `.distinct.size` is used to count distinct elements. It suggests using `.toSet.size` or `.distinct.length` (for arrays) directly. By using a set conversion, it clarifies intent to count unique elements and can be more efficient.                                                                                                | **Before:** `val count = xs.distinct.size`<br>**After:** `val count = xs.toSet.size`                                                                                                                                                                                            |
| **MapFlattenFlatMap**                                                               | Merges a map operation that produces an `Option`/`Iterable` with an immediate `.flatten` into a single flatMap. This avoids creating an intermediate structure and directly produces the flattened result, aligning with idiomatic usage.                                                                                                                    | **Before:** `val res = opt.map(getList).flatten`<br>**After:** `val res = opt.flatMap(getList)`                                                                                                                                                                                 |
| **MapSequenceTraverse**                                                             | See *FlatTraverse* – this rule specifically looks for `.map(...).sequence` patterns (often with `Future`, `Option`, etc.) and replaces them with `traverse`. The result is more idiomatic functional code using a single higher-order operation.                                                                                                             | **Before:** `val outs = list.map(fetch).sequence`<br>**After:** `val outs = list.traverse(fetch)`                                                                                                                                                                               |
| **MapToForeach**                                                                    | Replaces usage of `.map` on a collection purely for side effects with `.foreach`. If the result of a map is not used (only for its effect), this rule uses `foreach` to make intent clear and avoid building an unused collection.                                                                                                                           | **Before:** `xs.map(doSideEffect)` (result unused)<br>**After:** `xs.foreach(doSideEffect)`                                                                                                                                                                                     |
| **MatchParentheses**                                                                | Adjusts pattern matches that involve parentheses to comply with Scala 3’s rules. It might insert or remove parentheses in pattern matching where Scala 2 was lenient but Scala 3 is strict—for example, around tuple patterns or extra parentheses in `match` cases.                                                                                         | **Before:** `x match { case (y) => ... }`<br>**After:** `x match { case y => ... }`                                                                                                                                                                                             |
| **NamedParamOrder**                                                                 | Detects and optionally reorders named parameters in calls to match the definition order. While Scala allows passing parameters in any order if named, this rule may enforce the declaration order for consistency and readability in function calls.                                                                                                         | **Before:** `open(file = "data.txt", mode = "w")` (if declared as `def open(mode, file)`)<br>**After:** `open(mode = "w", file = "data.txt")`                                                                                                                                   |
| **NoElse**                                                                          | Flags `if` expressions that have an empty or redundant `else` branch. For example, an `if (cond) doSomething else ()` is unnecessary; this rule suggests removing the `else` or refactoring the code to avoid a no-op else branch.                                                                                                                           | **Before:** `if (valid) process() else {}`<br>**After:** `if (valid) process()`                                                                                                                                                                                                 |
| **ObjectFinal**                                                                     | Warns if a Scala `object` is declared `final`. Since objects cannot be subclassed, marking them final is redundant. This rule highlights and encourages removal of the `final` modifier on objects.                                                                                                                                                          | **Before:** `final object Util`<br>**After:** `object Util`                                                                                                                                                                                                                     |
| **ObjectSelfType**                                                                  | Removes unnecessary self-type annotations of an object to itself. If an object has `self: MyObject.type =>` or similar, it’s pointless (an object is itself); this rule drops such self-references, cleaning up the code.                                                                                                                                    | **Before:** `scala object Foo { self: Foo.type => ... }`<br>**After:** `scala object Foo { ... }`                                                                                                                                                                               |
| **OptionContains**                                                                  | Uses the `Option.contains` method for clarity when checking if an Option holds a specific value. It will rewrite patterns like `opt.exists(_ == value)` or manual comparisons to the more direct `opt.contains(value)`.                                                                                                                                      | **Before:** `if(opt.exists(_ == "ok")) ...`<br>**After:** `if(opt.contains("ok")) ...`                                                                                                                                                                                          |
| **OptionFilter**                                                                    | Simplifies chains where an `Option` is filtered and then perhaps checked. For example, if code does `opt.filter(p).isDefined`, it could be turned into `opt.exists(p)`. In general, it refines usage of `Option#filter` to more idiomatic patterns if available.                                                                                             | **Before:** `if(opt.filter(valid).isEmpty) ...`<br>**After:** `if(!opt.exists(valid)) ...`                                                                                                                                                                                      |
| **OptionForallExists**                                                              | Encourages using `forall` or `exists` appropriately on Options instead of more verbose constructs. For instance, `opt.map(p).getOrElse(true)` is equivalent to `opt.forall(p)`, and `opt.map(p).getOrElse(false)` is `opt.exists(p)`. The rule makes this substitution.                                                                                      | **Before:** `opt.map(isValid).getOrElse(true)`<br>**After:** `opt.forall(isValid)`                                                                                                                                                                                              |
| **OptionGetOrElse**                                                                 | Rewrites manual Option unpacking with default values to use `.getOrElse`. For example, it will replace patterns like `if(opt.isDefined) opt.get else default` with `opt.getOrElse(default)`, resulting in cleaner, more idiomatic code.                                                                                                                      | **Before:** `val v = if(opt.isDefined) opt.get else defVal`<br>**After:** `val v = opt.getOrElse(defVal)`                                                                                                                                                                       |
| **OptionGetWarn**                                                                   | Flags any usage of `Option.get`, which is unsafe. It serves as a linter to discourage calling `.get` on Options (which can throw if None), prompting the developer to use safer alternatives like `getOrElse`, pattern matching, or `fold`.                                                                                                                  | **Before:** `val x = opt.get`<br>**After:** *Warns to use safe alternative (e.g. `opt.getOrElse(...)`)*                                                                                                                                                                         |
| **OptionMapFlatMap**                                                                | Simplifies nested Options by merging successive map and flatMap calls. If an Option is `map`ped to another Option, yielding an `Option[Option[T]]`, and then flattened, this can be directly expressed as a single flatMap. (This is similar to *FlatMapCollect* but for Option chains.)                                                                     | **Before:** `maybeInt.map(i => computeOption(i)).flatten`<br>**After:** `maybeInt.flatMap(computeOption)`                                                                                                                                                                       |
| **OptionMatchToRight**                                                              | Replaces pattern matching on an Option to produce an Either with the direct `toRight` or `toLeft` methods. For example, turning an Option into an Either by matching Some/None can be done via `option.toRight(alternative)` more succinctly.                                                                                                                | **Before:** `scala opt match { case Some(v) => Right(v); case None => Left(err) }`<br>**After:** `opt.toRight(err)`                                                                                                                                                             |
| **OptionOrElse**                                                                    | Simplifies nested Option fallbacks by using `.orElse`. If code does `if(opt.isDefined) opt else otherOpt`, the rule rewrites it to `opt.orElse(otherOpt)`, making use of Option’s combinator for providing an alternative.                                                                                                                                   | **Before:** `val result = if(opt.isDefined) opt else altOpt`<br>**After:** `val result = opt.orElse(altOpt)`                                                                                                                                                                    |
| **OptionWhenUnless**                                                                | Replaces manual creation of Options based on conditions with `Option.when` or `Option.unless`. For instance, instead of `if(cond) Some(x) else None`, it uses `Option.when(cond)(x)` for conciseness and clarity (and similarly for the negated condition).                                                                                                  | **Before:** `val opt = if(cond) Some(value) else None`<br>**After:** `val opt = Option.when(cond)(value)`                                                                                                                                                                       |
| **ParameterUntuplingCaseWarn**                                                      | Warns about using pattern matching in lambda parameters (tuple unpacking in lambdas) which is no longer automatically allowed in Scala 3. It calls attention to code like `_.map{ case (a,b) => ... }`, suggesting it may need explicit handling or rewriting (see *RemoveParameterUntuplingCase*).                                                          | **Before:** `pairs.map{ case (x,y) => x+y }` (valid in Scala 2)<br>**After:** *Warning:* Scala 3 requires different syntax (see fix below)                                                                                                                                      |
| **PartialFunctionCondOpt**                                                          | Encourages using `PartialFunction.condOpt` for certain pattern-match expressions that yield an Option. If code does a match that returns Some(...) or None, this rule can shorten it to `condOpt`, which is a concise combinator for that purpose.                                                                                                           | **Before:** `scala x match { case n: Int if n>0 => Some(n); case _ => None }`<br>**After:** `PartialFunction.condOpt(x){ case n: Int if n>0 => n }`                                                                                                                             |
| **RedundantCaseClassVal**                                                           | Removes redundant `val` keywords in case class constructor parameters. In Scala, case class parameters are public vals by default, so explicitly marking them `val` is unnecessary. This rule drops the extra `val` for brevity.                                                                                                                             | **Before:** `case class Point(val x: Int, val y: Int)`<br>**After:** `case class Point(x: Int, y: Int)`                                                                                                                                                                         |
| **RemoveEmptyObject**                                                               | Eliminates empty `object` declarations that have no members or meaningful purpose. An object with an empty body is often unnecessary boilerplate; this rule deletes it to reduce clutter, assuming it’s safe to do so.                                                                                                                                       | **Before:** `scala object Temp { }`<br>**After:** *(Object removed entirely)*                                                                                                                                                                                                   |
| **RemoveIf**                                                                        | Simplifies `if` expressions that only call another expression without an else, especially if they return Unit. For example, an `if` that does nothing in the else branch could be refactored or removed. This rule may also remove redundant `if(true)` wrappers.                                                                                            | **Before:** `if(condition) doWork()` (with no else)<br>**After:** *(Same effect but without redundant conditional structure)*                                                                                                                                                   |
| **RemoveParameterUntuplingCase**                                                    | Rewrites lambdas that use tuple pattern parameters into a form compatible with Scala 3. It removes the `case` pattern from the parameter list by introducing an explicit binding. This makes code like `{ case (a,b) => ... }` into `{ t => val (a,b) = t; ... }`.                                                                                           | **Before:** `pairs.map{ case (a,b) => f(a,b) }`<br>**After:** `pairs.map{ t => val (a,b) = t; f(a,b) }`                                                                                                                                                                         |
| **RemovePureEff**                                                                   | Flags occurrences of constructing a pure effect (from an effect library like cats-effect’s `IO.pure` or similar) where it’s not needed. It might suggest using a value directly instead of wrapping it in a no-op effect, thus simplifying code.                                                                                                             | **Before:** `IO.pure(42)` (when just using 42 would do)<br>**After:** `42` (use the value directly, or no effect wrapper)                                                                                                                                                       |
| **RemoveSamePackageImport**                                                         | Removes imports that reference the same package as the current file (which are unnecessary). If you import something from your file’s own package, Scala finds it without an import. This rule deletes such superfluous import statements.                                                                                                                   | **Before:** In package `util`, file has `import util.Helper`<br>**After:** *(Import removed, since Helper is in same package)*                                                                                                                                                  |
| **RemoveStringInterpolation**                                                       | Simplifies string interpolations that don’t actually interpolate any variables. For example, it will change an interpolated string with no placeholders (like s"hello") into a plain string literal ("hello"), as the `s` is unneeded.                                                                                                                       | **Before:** `scala val msg = s"Hello world"`<br>**After:** `scala val msg = "Hello world"`                                                                                                                                                                                      |
| **RemoveUselessParamComments**                                                      | Removes Scaladoc `@param` entries that have no corresponding parameter or are just placeholders (like “@param x”). This cleans up Scaladoc by eliminating empty or useless parameter documentation tags that don’t add value or are outdated.                                                                                                                | **Before:** `/** Compute value. @param x  */ def compute(x: Int) = ...`<br>**After:** `/** Compute value. */ def compute(x: Int) = ...`                                                                                                                                         |
| **RepeatedRewrite**                                                                 | Suggests simplifying repeated code patterns or eliminates consecutive identical transformations. (For example, if code applies the same operation twice in a row unintentionally, this rule would merge or remove the duplicate operation.) The result is more efficient, non-redundant code.                                                                | **Before:** `list.distinct.distinct`<br>**After:** `list.distinct`                                                                                                                                                                                                              |
| **ReplaceFill**                                                                     | Replaces usage of `List.fill` or similar collection fill constructors with more idiomatic alternatives when applicable. For instance, if a fill is used in a context better served by another method or a constant, this rule will suggest the change.                                                                                                       | **Before:** `List.fill(3)("hello").mkString(",")`<br>**After:** `"hello,hello,hello"` (direct repetition or alternative method)                                                                                                                                                 |
| **ReplaceMapContains**                                                              | Rewrites manual checks for map keys to use `.contains`. For example, it will turn `map.get(key).isDefined` into `map.contains(key)`, which directly checks key existence. This yields clearer and possibly more efficient key presence checks.                                                                                                               | **Before:** `if(map.get(k).isDefined) ...`<br>**After:** `if(map.contains(k)) ...`                                                                                                                                                                                              |
| **ReplacePlaceholder**                                                              | Updates deprecated underscore placeholders in certain expressions to the new syntax or explicit lambda. In Scala 3, some usages of `_` as a placeholder (for example in partial functions or type placeholders) are disallowed, so this rule replaces them with the proper syntax.                                                                           | **Before:** `val f = _.toString`<br>**After:** `val f = (x => x.toString)` (explicit lambda in Scala 3)                                                                                                                                                                         |
| **ReplaceSymbolLiterals**                                                           | Replaces Scala 2 symbol literals (e.g. `'mySymbol`) with an alternative since symbol literals are removed in Scala 3. Typically, it will convert `'name` to `Symbol("name")` or another appropriate representation (like an enum or string) depending on context.                                                                                            | **Before:** `val sym = 'MySym`<br>**After:** `val sym = Symbol("MySym")`                                                                                                                                                                                                        |
| **ReuseInstances**                                                                  | Identifies where new instances of an object are repeatedly created when a single reusable instance would suffice. It suggests reusing a val instead of calling a constructor or method multiple times for the same result, reducing unnecessary allocations.                                                                                                 | **Before:** `scala if(x.matches(regex) && y.matches(regex))` (regex compiled twice)<br>**After:** `scala val r = regex.r; if(r.matches(x) && r.matches(y))`                                                                                                                     |
| **SameParamOverloading**                                                            | Warns when multiple overloaded methods have parameters with the same types in the same order, which can lead to ambiguity. It encourages differentiating the parameter types or names, or merging the overloads, since identical param signatures make overload resolution tricky.                                                                           | **Before:** `def f(x:Int): Unit = ...; def f(y:Int): String = ...`<br>**After:** *No duplicate-type overloads (methods merged or renamed)*                                                                                                                                      |
| **Scala3ImportRewrite**                                                             | Updates import statements that are unnecessary or changed in Scala 3. For example, it might remove implicit import of `scala.collection.compat._` or rewrite certain wildcard imports to specific ones if Scala 3 handles them differently, ensuring compatibility.                                                                                          | **Before:** `import scala.collection.JavaConverters._` (deprecated in 3)<br>**After:** `import scala.jdk.CollectionConverters._`                                                                                                                                                |
| **Scala3ImportWarn**                                                                | Lints imports that will not be needed or have different semantics in Scala 3. It flags these at compile-time so developers can remove or change them. This includes redundant compatibility imports or anything made unnecessary by Scala 3’s standard library.                                                                                              | **Before:** `import scala.compat.java8.FutureConverters._`<br>**After:** *Warns that this import is obsolete in Scala 3*                                                                                                                                                        |
| **Scala3Placeholder**                                                               | Adjusts code that used Scala 2’s wildcard placeholders in ways that Scala 3 disallows. For example, Scala 3 doesn’t allow `_` for throwing away values in certain contexts. This rule replaces such placeholders with explicitly named dummy variables or the new underscore usage that Scala 3 permits.                                                     | **Before:** `list.foreach { _ => doSomething() }`<br>**After:** `list.foreach { _ => doSomething() }` (Scala 3 allows this differently, or uses a named `_` parameter)                                                                                                          |
| **ScalaApp**                                                                        | Rewrites usage of the deprecated `scala.App` trait to an explicit `main` method. It converts classes or objects extending `App` into objects with a `def main(args: Array[String]): Unit` that calls the same code, since Scala 3 drops `App` trait support.                                                                                                 | **Before:** `object MyApp extends App { println("Started") }`<br>**After:** `object MyApp { def main(args: Array[String]): Unit = { println("Started") } }`                                                                                                                     |
| **ScalazEitherInfix**                                                               | Converts Scalaz’s infix `\/` (either) type or related usage into standard Scala/Cats Either. It will replace types or constructors like `A \/ B` with `Either[A,B]` or appropriate code, since Scala 3 and modern Scala prefer the standard Either over Scalaz’s.                                                                                            | **Before:** `def result: String \/ Int = Right(5)`<br>**After:** `def result: Either[String, Int] = Right(5)`                                                                                                                                                                   |
| **SeparateEachFileConfig** / **SeparateEachFileRewrite** / **SeparateEachFileWarn** | A set of rules that allow configuration on a per-file basis. They likely ensure that certain rewrites or lint warnings apply one file at a time or separately. For example, they might enforce that some transformations (like organizing imports or formatting) are done file-by-file rather than across the whole project, providing fine-grained control. | **Example:** When enabled, each source file is processed independently according to configured sub-rules, so a change in one file (like import sorting) doesn't affect others. (These rules themselves do not change code directly but alter how other rules operate per file.) |
| **SimplifyForYield**                                                                | Simplifies for-comprehensions that yield Unit or otherwise could be expressed more directly. If a for-yield is effectively used for side effects (yielding Unit), this rule may drop the yield part entirely or simplify the comprehension into a `foreach`.                                                                                                 | **Before:** `for(x <- xs; y <- ys) yield ()`<br>**After:** `for(x <- xs; y <- ys) { }` (or `xs.foreach(x => ys.foreach(y => ...))`)                                                                                                                                             |
| **SizeToLength**                                                                    | Rewrites calls to `.size` into `.length` for types where length is more conventional (specifically on Strings or arrays). On `String` and array, `.length` is the idiomatic property (and slightly more efficient).                                                                                                                                          | **Before:** `if(str.size == 0) ...`<br>**After:** `if(str.length == 0) ...`                                                                                                                                                                                                     |
| **SlickFilter**                                                                     | Addresses common Slick (database query) misuses, possibly warning if a Slick query uses `filter` where a comprehension or conditional join is more appropriate. It might also ensure `.filter` calls in Slick are not ignored (since they build queries).                                                                                                    | **Before:** `users.filter(_.age < 18)` (and not using result)<br>**After:** *Warns or refactors to properly use the filtered query (e.g. in a comprehension)*                                                                                                                   |
| **StringFormatToInterpolation**                                                     | Transforms uses of `String.format` into Scala string interpolation. It finds patterns of `String.format("...%s...", expr)` or `format` method calls and replaces them with equivalent s"`...$expr...`" strings, which are more idiomatic in Scala.                                                                                                           | **Before:** `String.format("Hello %s", name)`<br>**After:** `s"Hello $name"`                                                                                                                                                                                                    |
| **SyntacticOrganizeImports**                                                        | Similar to Scalafix’s standard OrganizeImports, but works syntactically (without semantic info). It sorts and groups import statements in a file, removes duplicates, and organizes them according to configured rules, purely via textual analysis.                                                                                                         | **Before:** (Unsorted imports)<br>**After:** (Imports sorted alphabetically and grouped, duplicates removed)                                                                                                                                                                    |
| **ThrowableToNonFatal**                                                             | Changes catches of `Throwable` to catch `NonFatal` instead. Catching all Throwables can swallow critical errors (like `OutOfMemoryError`); this rule narrows broad catches to NonFatal (from `scala.util.control.NonFatal`) which excludes serious exceptions.                                                                                               | **Before:** `try { ... } catch { case e: Throwable => ... }`<br>**After:** `try { ... } catch { case NonFatal(e) => ... }`                                                                                                                                                      |
| **UnmooredDocComment**                                                              | Detects Scaladoc comments that are not attached to any code (floating comments) and removes or flags them. Such unmoored comments might not be picked up by documentation tools; the rule helps maintain only relevant documentation tied to code elements.                                                                                                  | **Before:** `/** This is a comment for something that was removed */` (sits alone)<br>**After:** *(Comment deleted or moved to the correct place)*                                                                                                                              |
| **UnnecessaryCase**                                                                 | Simplifies case expressions or partial functions that can be written more directly. For example, it might remove a `case x => x` in a pattern match that simply returns the value unchanged, or eliminate needless case wrapping in anonymous functions when not needed.                                                                                     | **Before:** `list.map{ case x => x * 2 }`<br>**After:** `list.map(x => x * 2)`                                                                                                                                                                                                  |
| **UnnecessaryMatch**                                                                | Flags `match` expressions that are essentially no-ops or could be replaced by a simpler expression. For instance, `x match { case true => ... case false => ... }` might be better written as an if, or a match that just returns the value itself can be removed.                                                                                           | **Before:** `status match { case 0 => "ok"; case _ => "ok" }`<br>**After:** `"ok"`                                                                                                                                                                                              |
| **UnnecessarySort**                                                                 | Warns about sorting a collection when it's not needed for the next operation. For example, calling `.sorted` or `.sortBy` and then only taking a head element can be replaced with a min/max computation instead of a full sort. This rule highlights such inefficiencies.                                                                                   | **Before:** `val smallest = list.sorted.head`<br>**After:** `val smallest = list.min`                                                                                                                                                                                           |
| **UnnecessarySortRewrite**                                                          | Automates the fix for cases identified by *UnnecessarySort*. It will rewrite code that sorts and then picks elements (like taking head/tail) into code that directly computes the desired element (using `.min`, `.max`, etc.), avoiding the full sort.                                                                                                      | **Before:** `val first = xs.sortBy(_.size).head`<br>**After:** `val first = xs.minBy(_.size)`                                                                                                                                                                                   |
| **UnusedConstructorParams**                                                         | Removes constructor parameters that are not used inside the class. If a class takes a parameter that is never referenced, this rule can safely delete that parameter (and any corresponding arguments at instantiation), cleaning up the class API.                                                                                                          | **Before:** `class Person(name: String, unused: Int) { def greet = "Hi " + name }`<br>**After:** `class Person(name: String) { def greet = "Hi " + name }`                                                                                                                      |
| **UnusedSelfType**                                                                  | Removes self-type annotations on classes or traits when the self identifier is never used. If a trait has something like `self: SomeTrait =>` but doesn’t actually use `self`, this rule drops the self-type to simplify the declaration.                                                                                                                    | **Before:** `scala trait T { self: Logging => def f = log("hi") }` (if `self` not used explicitly)<br>**After:** `scala trait T extends Logging { def f = log("hi") }`                                                                                                          |
| **UnusedTypeParams**                                                                | Eliminates type parameters that are declared but not used in a class or method. For example, if `class Container[T]` doesn’t actually use `T` in its body, the rule will remove `<T>` from the declaration, avoiding confusion and unused abstractions.                                                                                                      | **Before:** `class Wrapper[T](val value: Int)` (T not used)<br>**After:** `class Wrapper(val value: Int)`                                                                                                                                                                       |
| **UselessParamCommentsWarn**                                                        | Warns about Scaladoc parameter comments that are deemed useless (for instance, comments that just repeat the parameter name or provide no additional info). It nudges developers to either remove such comments or enhance them with meaningful descriptions.                                                                                                | **Before:** `/** @param x x value */ def foo(x: Int) = ...`<br>**After:** *Warning: useless param doc for `x`*                                                                                                                                                                  |
| **UsingParamAnonymous**                                                             | Simplifies anonymous context (given/using) parameters by omitting the parameter name when it’s not used. In Scala 3, you can define `def f(using Context)` instead of `def f(using ctx: Context)` if `ctx` isn’t referenced. This rule applies that change.                                                                                                  | **Before:** `def run()(using c: Context): Unit = {...}` (c not used)<br>**After:** `def run()(using Context): Unit = {...}`                                                                                                                                                     |
| **UsingParamAnonymousConstructor**                                                  | Does the same as *UsingParamAnonymous* but for constructor context parameters. If a class constructor has an unused given parameter, it drops the name. This results in a cleaner definition while retaining the implicit context injection in Scala 3.                                                                                                      | **Before:** `class Service(using cfg: Config) { ... }` (cfg not used)<br>**After:** `class Service(using Config) { ... }`                                                                                                                                                       |
| **WithFilter**                                                                      | Flags use of `.withFilter` in for-comprehensions or chains where it might lead to unintended behavior. Scala’s `withFilter` can defer filtering and is used in for-comprehensions; this rule encourages caution or the use of alternatives like `filter` for clarity, especially outside of for-comprehensions.                                              | **Before:** `collection.withFilter(cond).map(f)`<br>**After:** `collection.filter(cond).map(f)` (or ensure usage is intentional)                                                                                                                                                |
| **WithLeftWithRight**                                                               | Rewrites or warns on usage of methods named `withLeft`/`withRight` (for instance, in older versions of Either or libraries) now that Either is right-biased. The rule likely suggests using standard `Left` or `Right` constructors or direct Either methods instead of any legacy transitional helpers.                                                     | **Before:** `val r = Right(1).withLeft[String]`<br>**After:** `val r: Either[String, Int] = Right(1)` (type ascription or direct Either used)                                                                                                                                   |
